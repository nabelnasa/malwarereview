# BAB II Menulis _rules_ YARA
By:Nabella Permatasari

## 2.3 Condition
Condition merupakan ekspresi Boolean namun penggunaannya tidak seluas ekspresi Boolean pada bahasa pemrograman biasa, contohnya dalam pernyataan `if`. Condition dapat berisi
1. Operator Boolean khas `and` `or` `and not`
2. Operator relasi `>=` `<=` `<` `>` `==` `!=`
3. Operator aritmatika `+` `-` `*` `\` `%`
4. Operator bitwise `&` `|` `<<` `>>` `~` `^`
5. Ekspresi numerik

Dalam suatu kondisi, dapat juga menggunakan indetifikasi `string` sebagai variabel Boolean yang nilainya bergantung pada ada atau tidaknya `string` terkait dalam file.

```
rule Example
{
  strings:
    $a="text 1"
    $b="text 2"
    $c="text 3"
    $d="text 4"

  condition:
    ($a or $b) and ($c or $d)
}
```

### 2.3.1 Counting string
Terkadang kita perlu tahu tidak hanya mengenai keberadaan `strings` tertentu, tapi berapa kali  `strings` tersebut muncul dalam file atau dalam proses memori. Jumlah kemunculan setiap `strings` direpresentasikan dengan sebuah variabel yang bernama `strings` identifier dengan mengganti karakter `$` menjadi `#`. Berikut contohnya:
```
rule CountExample
{
  strings:
    $a="dummy 1"
    $b="dummy 2"

  condition:
    #a == 6 and #b > 10
}
```
rule ini cocok dengan file yang memproses $a sebanyak 6 kali dan $b lebih dari 10 kali.

### 2.3.2 String offset atau virtual addresses
Untuk mengetahui letak `strings` pada offset atau alamat virtual tertentu dalam file, maka digunakan operator `at`. Contohnya sebagai berikut
```
rule AtExample
{
  strings:
      $a="dummy 1"
      $b="dummy 2"

  condition:
      $a at 100 and $b at 200
}
```
rule tersebut bernilai benar jika $a terdapat dalam proses di offset 100 atau alamat virtual status, dan $b terdapat dalam proses di offset 200 atau alamat virtual 200. Offset harus dinyatakan dalam bentuk desimal, apabila diganti menjadi bentuk heksadesimal, maka ditambah 0x seperti pada pemrograman C, yang sangat bermanfaat dalam penulisan alamat virtual. Dan penggunaan operator `at` harus didahulukan dibanding operator `and`.

Operator `at` dapat digunakan untuk mencari sebuah `strings` pada offset atau alamat virtual tertentu pada sebuah proses memori, sedangkan operator `in` dapat digunakan untuk mencari `strings` pada rentang offset atau alamat virtual tertentu. Berikut contohnya

```
rule InExample
{
  strings:
    $a="dummy 1"
    $b="dummy 2"

  condition:
    $a in (0 .. 100) and $b in (100..filesize)
}
```

Pada contoh diatas, `strings` $a harus ditemukan diantara offset 0 sampai 100, sedangkan $b harus ditemukan pada offset 100 sampai akhir dari file. Angka offset secara default adalah bentuk desimal.

Dapat juga mendapatkan kemunculan `string` `$a` pada ke-i offset atau alamat virtual dengan menggunakan @a[i]. i berbasis satu, sehingga basis pertama adalah @a[1], kedua @a[2] dan seterusnya. Jika indeks yang dituju lebih besar dari offset/alamat virtual yang muncul maka nilainya akan NaN (Not A Number).

### 2.3.3 Match length
Pada regular expression dan hex string yang mengandung jump, panjang **match** adalah variabel. Jika kamu memiliki regular expression /fo*/ maka string "fo" "foo" dan "fooo" semuanya cocok, meskipun dengan panjang yang berbeda.

Kamu dapat menggunakan match sebagai sebuah condition dengan menambahkan karakter `!` didepan string identifier, hal ini sama dengan penggunaan `@` pada offset.

`!a[1]` adalah panjang match pertama, `!a[2]` adalah panjang untuk match kedua dan seterusnya. Sedangkan `!a` = `!a[1]`.

### 2.3.4 File size
Tidak hanya variabel yang dapat muncul di condition, ada variabel khusus yang dapat digunakan dengan baik. Salah satu dari variabel khusus ini adalah `filesize`, yang dapat menampung ukuran file yang akan dipindai. Ukuran file diekspresikan dalam bytes.

```
rule FileSizeExample
{
  condition:
      filesize > 200KB
}
```
Pada contoh sebelumnya dicontohkan juga penggunaan KB di postfix. Postfix ini apabila disandingkan dengan sebuah angka tetap, secara otomatis hasilnya akan dikalikan 1024, sedangkan MB dapat digunakan untuk mengalikan hasilnya dengan 2^2. Kedua postfix hanya digunakan dengan angka desimal.

Kegunaan dari `filesize` hanya berguna ketika rule akan dijalankan pada sebuah file. Namun jika rule dijalankan pada sebuah proses, `filesize` tidak bermanfaat, karena tidak cocok dengan konteks tersebut.

### 2.3.5 Executable entry point
Variabel khusus lain yang bisa digunakan adalah `entrypoint`. Jika sebuah fiel Portable Executable (PE) atau Executable dan Linkable Format (ELF), variabel ini menampung nilai entry point dari executable, dengan kata lain kita melakukan scanning file. Jika kita melakukan scanning pada proses yang berjalan, entry point akan menampung alamat virtual dari entry point utama dari executable. Penggunaan khusus variabel ini adalah beberapa pola entry point untuk mendeteksi packer atau file infektor sederhana.

```
rule EntryPointExample1
{
  strings:
      $a = { E8 00 00 00 00 }

  condition:
      $a at entrypoint
}

rule EntryPointExample2
{
  strings:
      $a = { 9C 50 66 A1 ?? ?? ?? 00 66 A9 ?? ?? 58 0F 85 }

  condition:
      $a in (entrypoint..entrypoint + 10)
}
```
Adanya variabel `entrypoint` pada sebuah rule, menandakan bahwa syarat file adalah PE atau ELF. Jika file bukan PE atau ELF maka rule yang terdapat dalam file akan bernilai salah.

|```Warning: Varibel `entrypoint` termasuk variabel yang sudah usang, kamu seharusnya menggunakan `pe.entry_point`dari PE module. Mulai dari YARA 3.0 kamu akan mendapatkan warning saat menggunakan `entrypoint` dan akan dihilangkan pada versi selanjutnya.```

### 2.3.6 Accessing data at given position
Ada banyak situasi dimana kamu ingin menulis kondisi berdasarkan data yang tersimpan pada file offset tertentu atau alamat virtual, tergantung pada proses scanning kita lakukan pada sebuah file atau sebuah proses berjalan. Dalam situasi ini kamu dapat menggunakan salah satu dari fungsi berikut untuk membaca data data file dari offset yang ada.

```
int8(<offset or virtual address>)
int16(<offset or virtual address>)
int32(<offset or virtual address>)

uint8(<offset or virtual address>)
uint16(<offset or virtual address>)
uint32(<offset or virtual address>)

int8be(<offset or virtual address>)
int16be(<offset or virtual address>)
int32be(<offset or virtual address>)

uint8be(<offset or virtual address>)
uint16be(<offset or virtual address>)
uint32be(<offset or virtual address>)
```
Fungsi **intXX** membaca 8,16 atau 32 bit **signed integer** dari (offset atau alamat virtual. Fungsi **uintXX** membaca **unsigned integer**. Baik 16 atau 32 bit integer dipertimbangkan sebagai _little-endian_. Jika ingin membaca sebuah _big_endian_, maka dibelakang fungsi yang sesuai ditambah dengan `be`. Parameter (offset atau alamat virtual) dapat menjadi ekspresi apapun, kembali pada sebuah _unsigned interger_, termasuk mengembalikan nilai pada salah satu fungsi `uintXX` nya sendiri. Berikut contoh sebuah rule untuk membedakan file PE:

```
rule IsPE
{
  condition:
  // MZ signature at offset 0 and ...
  uint16(0) == 0x5A4D and
  // ... PE signature at offset stored in MZ header at 0x3C
  uint32(uint32(0x3C)) == 0x00004550
}
```

### 2.3.7 Set of strings
Terdapat keadaan dimana dibutuhkan suatu pernyataan bahwa file terkait harus mengandung sejumlah strings dari sebuah himpunan yang ada.Tidak ada syarat strings tersebut harus ada dalam himpunan, namun minimal ada beberapa diantara mereka harus ada. Dalam situasi ini operator `of` yang digunakan.
```
rule OfExample1
{
  strings:
    $a = "dummy1"
    $b = "dummy2"
    $c = "dummy3"
  condition:
    2 of ($a,$b,$c)

}
```
Syarat dari rule diatas adalah minimal harus ada 2 string diantara ($a,$b,$c) yang ada pada file. Saat menggunakan operator ini, angka sebelum `of` harus kurang dari sama dengan jumlah string pada himpunan.

Unsur dari himpunan tidak harus secara eksplisit dinyatakan dalam bentuk angka, namun dapat menggunakan wild card. Contohnya:

```
rule OfExample2
{
  strings:
    $foo1 = "foo1"
    $foo2 = "foo2"
    $foo3 = "foo3"

  condition:
  2 of ($foo*)
}

rule OfExample3
{
  strings:
    $foo1 = "foo1"
    $foo2 = "foo2"

    $bar1 = "bar1"
    $bar2 = "bar2"

  condition:
    3 of ($foo*,$bar1,$bar2)
}

rule OfExample4
{
  strings:
    $a = "dummy1"
    $b = "dummy2"
    $c = "dummy3"

  condition:
    1 of them // equivalent to ($*)
}
```

Ekpresi any dan  all juga dapat digunakan:
```
all of them       // all strings in the rule
any of them       // any string in the rule
all of ($a*)      // all strings whose identifier starts by $a
any of ($a,$b,$c) // any of $a, $b or $c
1 of ($*)         // same that "any of them"
```

### 2.3.8 Applying the same condition to many strings
Ada operator yang sama dengan operator `of` tapi lebih powerful, yaitu `for. .of`.
```
for expression of string_set : (boolean expression)
```
Artinya, dari string set `string_set` minimal `expression` nya harus memenuhi `boolean expression`.
Dengan kata lain, `boolean expression` menilai setiap string pada `string_set` dan di dalamnya minimal harus ada `expression` yang bernilai True.

`boolean expression` dapat berisi berbagai boolean expression yang diterima pada bagian `condition`, kecuali untuk rincian penting berikut: kamu dapat (seharusnya) menggunakan ($) sebagai penunjuk tempat untuk string yang akan dinilai.
```
for any of ($a,$b,$c) : ($ at entrypoint)
```
Simbol ($) dalam ekspresi boolean tidak melekat pada string tertentu, bisa jadi $a, $b atau $c dan semuanya bisa dijalankan.

Mungkin kamu telah merealisasikan bahwa `of` adalah sebuah kondisi khusus untuk `for . . of`. Berikut merupakan ekspresi yang sama:
```
any of ($a,$b,$c)
for any of ($a,$b,$c) : ( $ )
```
Kamu juga dapat menggunakan simbol `#` dan `@` untuk mengacu pada jumlah kejadian pada offset pertama dari setiap string.
```
for all of them : ( # > 3 )
for all of ($a*) : ( @ > @b )
```
### 2.3.9 Using anonymous strings with `of` or `for of`
Ketika menggunakan operator `of` atau `for .. of` yang diikuti dengan `them`, biasanya identifier berlebihan dalam mengarahkan setiap string dalam rule. Dalam kondisi ini, tidak mereferesikan string apapun secara terpisah sehingga tidak dibutuhkan indenfikasi khusus untuk setiap string. Kondisi dapat menggunakan anonimus string dengan indenfier yang hanya terdiri dari karakter $. Berikut contohnya:
```
rule AnonymousStrings
{
  strings:
      $ = "dummy1"
      $ = "dummy2"

  condition:
      1 of them
}
```

### 2.3.10 Iterating over string occurrences
Seperti pada _string offset_ atau alamat virtual, dimana sebuah string yang muncul pada sebuah file atau sebuah proses dapat diakses menggunakan sintak `@a[i]`, `i` merupakan indeks yang mengindenfikasi dimana string `$a` yang dituju.
Terkadang kamu ingin mengulangi beberapa dari offset ini dan mempertahankan nya pada kondisi yang diberikan. Contohnya:

```
rule Occurrences
{
  strings:
      $a = "dummy1"
      $b = "dummy2"

  condition:
      for all i in (1,2,3) : (@a[i] + 10 == @b[i])
}
```
Rule diatas menyatakan bahwa 

### 2.3.11 Refencing other rule
